package com.tngtech.valueprovider;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.RoundingMode;
import java.net.MalformedURLException;
import java.net.URL;
import java.text.DecimalFormat;
import java.time.Duration;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.Month;
import java.util.ArrayList;
import java.util.Collection;
import java.util.EnumSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.UUID;
import java.util.function.Function;
import java.util.stream.Collectors;

import com.google.common.collect.Iterables;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.Lists.asList;
import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Lists.newArrayListWithCapacity;
import static com.google.common.collect.Sets.newHashSet;
import static java.lang.String.format;
import static java.time.LocalDateTime.now;
import static java.time.temporal.ChronoUnit.DAYS;
import static java.time.temporal.ChronoUnit.SECONDS;
import static java.util.Arrays.asList;

@SuppressWarnings("WeakerAccess")
public class ValueProvider {
    static final int SUFFIX_LENGTH = 3;
    static final String NUMERIC_STRING = "12345678901234567890123456789012345678901234567890123456789012345678901234567890";
    static final String MIXED_CASE_STRING =
            "ABCDEFGhijklmnopqrstuvwxyzabcdefghijkLMNOPqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklMNOpqrstuvwxyz";

    private final RandomValues random;
    private final String prefix;
    private final String suffix;
    private final LocalDateTime referenceLocalDateTime;

    protected ValueProvider(ValueProviderInitialization initialization) {
        this(initialization.getRandom(), "", initialization.getSuffix(), initialization.getReferenceLocalDateTime());
    }

    protected ValueProvider(
            RandomValues random,
            String prefix,
            String suffix,
            LocalDateTime referenceLocalDateTime) {
        checkNotNull(random, "random");
        checkNotNull(prefix, "prefix");
        checkNotNull(suffix, "suffix");
        checkNotNull(referenceLocalDateTime, "referenceLocalDateTime");
        this.random = random;
        this.prefix = prefix;
        this.suffix = suffix;
        this.referenceLocalDateTime = referenceLocalDateTime;
    }

    /**
     * Generates a byte array of random length.
     *
     * @return the generated byte array.
     */
    public byte[] byteArray() {
        return lowercaseString(intNumber(1, 1000)).getBytes();
    }

    /**
     * Generates a {@link UUID}.
     *
     * @return the generated uuid.
     */
    public UUID uuid() {
        return new UUID(positiveLongNumber(), positiveLongNumber());
    }

    /**
     * Decorates {@code base} with prefix {@link Builder#withConstantPrefix(String)} and suffix {@link Builder#withConstantSuffix(String)}.
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = new ValueProvider.Builder(createRandomInitialization())
     *                 .withConstantPrefix("AbC")
     *                 .withConstantSuffix("dEf")
     *                 .build();
     *         vp.fixedDecoratedString("input"); // -> "AbCinputdEf"
     * </pre>
     * </p>
     * <p>
     * Usually, it is sufficient to create the {@link ValueProvider} via the {@link ValueProviderFactory}, which generates a random suffix and leaves the prefix empty.
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.fixedDecoratedString("input"); // -> "inputZXy"
     * </pre>
     * </p>
     * <p>Note that prefix and suffix remain constant for the entire lifetime of each {@link ValueProvider} instance.</p>
     *
     * @param base the String to be decorated.
     * @return the decorated {@code base}.
     * @see #fixedDecoratedString(String, int)
     */
    public String fixedDecoratedString(String base) {
        return prefix + base + suffix;
    }

    /**
     * Decorates {@code base} with prefix {@link Builder#withConstantPrefix(String)} and suffix {@link Builder#withConstantSuffix(String)}.
     * <p>
     * If the resulting string is longer than the requested {@code maxLength},
     * the result is shortened as follows: The suffix is shortened first,
     * then the prefix, and finally the {@code base} String.
     * </p>
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = new ValueProvider.Builder(createRandomInitialization())
     *                 .withConstantPrefix("AbC")
     *                 .withConstantSuffix("dEf")
     *                 .build();
     *         vp.fixedDecoratedString("input", 15); // -> "AbCinputdEf"
     *         vp.fixedDecoratedString("input", 10); // -> "AbCinputdE"
     *         vp.fixedDecoratedString("input", 7); // -> "bCinput"
     *         vp.fixedDecoratedString("input", 4); // -> "inpu"
     * </pre>
     * </p>
     * <p>Note that prefix and suffix remain constant for the entire lifetime of each {@link ValueProvider} instance.</p>
     *
     * @param base      the String to be decorated.
     * @param maxLength the maximum length of the returned String.
     * @return the decorated {@code base} with maximum length of {@code maxLength}.
     * @see #fixedDecoratedString(String)
     */
    public String fixedDecoratedString(String base, int maxLength) {
        if (base.length() > maxLength) {
            return base.substring(0, maxLength);
        }

        String fullDecoratedString = fixedDecoratedString(base);
        if (fullDecoratedString.length() < maxLength) {
            return fullDecoratedString;
        }

        if ((prefix + base).length() >= maxLength) {
            return (prefix + base).substring((prefix + base).length() - maxLength);
        }
        return fullDecoratedString.substring(0, maxLength);
    }

    /**
     * Creates a {@link Function} that decorates Strings.
     *
     * @param decorateString the String to decorate.
     * @return the decorating {@link Function}.
     */
    public static Function<ValueProvider, String> creatorForFixedDecoratedString(final String decorateString) {
        return provider -> provider.fixedDecoratedString(decorateString);
    }

    /**
     * Creates a {@link Function} that generates Strings of {@code length}.
     *
     * @param length the length of the generated String.
     * @return the String generating {@link Function}.
     */
    public static Function<ValueProvider, String> creatorForRandomString(final int length) {
        return provider -> provider.randomString(length);
    }

    /**
     * Generates a {@link List} of 'decorated' strings. Please refer to {@link #fixedDecoratedString(String)} for details.
     *
     * @param number of strings to create
     * @return the {@link List} of generated strings
     * @see #fixedDecoratedStrings(int, String)
     * @see #fixedDecoratedString(String)
     */
    public List<String> fixedDecoratedStrings(int number) {
        return fixedDecoratedStrings(number, "string");
    }

    /**
     * Generates a {@link List} of 'decorated' strings using {@code base}. Please refer to {@link #fixedDecoratedString(String)} for details.
     *
     * @param number of strings to create
     * @param base   the string to be decorated.
     * @return the {@link List} of generated strings
     * @see #fixedDecoratedStrings(int)
     * @see #fixedDecoratedString(String)
     */
    public List<String> fixedDecoratedStrings(int number, String base) {
        List<String> strings = newArrayListWithCapacity(number);
        for (int i = 0; i < number; i++) {
            strings.add(format("%s %d", fixedDecoratedString(base), i));
        }
        return strings;
    }

    /**
     * Generates a String of {@code length} consisting of digits. It may contain leading '0's.
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.numericString(5); // -> "39596"
     * </pre>
     * </p>
     *
     * @param length the length of the generated String.
     * @return the generated String of length {@code length}.
     * @see #numericString(int, int, int)
     */
    public String numericString(int length) {
        return randomCharacters(NUMERIC_STRING, length);
    }

    /**
     * Generates a String representing the digits of a number in the interval [min, max].
     * If the number of digits of said number is smaller than the requested length, leading '0's are added.
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.numericString(2, 22, 44); // -> "26"
     *         vp.numericString(5, 22, 44); // -> "00041"
     * </pre>
     * </p>
     *
     * @param length the length of the generated String.
     * @param min    the lower limit (inclusive) of the generated number (as String).
     * @param max    the upper limit (inclusive) of the generated number (as String).
     * @return the generated String.
     * @throws IllegalArgumentException if {@code min} > {@code max}.
     * @throws IllegalArgumentException if {@code min} &lt;= 0.
     * @throws IllegalArgumentException if the requested length of the String is smaller than the number of digits of {@code min}.
     * @see #numericString(int)
     */
    public String numericString(int length, int min, int max) {
        checkArgument(min <= max, "min [%s] must be <= max [%s]", min, max);
        checkArgument(min > 0, "min [%s] must be >= 1", min);
        int minLength = ("" + min).length();
        checkArgument(length >= minLength,
                "requested length (%s digit(s)) must be >= the number of digits of 'min' [%s] (=%s digits)",
                length, min, minLength);

        int number = intNumber(min, max);
        return format("%0" + length + "d", number);
    }

    /**
     * Generates a String of {@code length} consisting of upper case and lower case characters.
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.randomString(5); // -> "DrtGc"
     * </pre>
     * </p>
     *
     * @param length the length of the generated String.
     * @return the generated String.
     * @see #lowercaseString(int)
     * @see #uppercaseString(int)
     */
    public String randomString(int length) {
        return randomCharacters(MIXED_CASE_STRING, length);
    }

    /**
     * Generates a String of {@code length} consisting of lower case characters.
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.lowercaseString(5); // -> "eicmf"
     * </pre>
     * </p>
     *
     * @param length the length of the generated String.
     * @return the generated String.
     * @see #uppercaseString(int)
     * @see #randomString(int)
     */
    public String lowercaseString(int length) {
        return randomString(length).toLowerCase();
    }

    /**
     * Generates a String of {@code length} consisting of upper case characters.
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.uppercaseString(5); // -> "EDJCT"
     * </pre>
     * </p>
     *
     * @param length the length of the generated String.
     * @return the generated String.
     * @see #lowercaseString(int)
     * @see #randomString(int)
     */
    public String uppercaseString(int length) {
        return randomString(length).toUpperCase();
    }

    private String randomCharacters(String from, int length) {
        return randomCharacters(from, length, random);
    }

    private static String randomCharacters(String from, int length, RandomValues random) {
        StringBuilder sb = new StringBuilder(length);
        for (int i = 0; i < length; i++) {
            sb.append(from.charAt(random.nextInt(from.length())));
        }
        return sb.toString();
    }

    /**
     * Generates an int number in [0 ; {@link Integer#MAX_VALUE}].
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.positiveIntNumber(); // -> 234684
     * </pre>
     * </p>
     *
     * @return the generated number.
     * @see #intNumber(int, int)
     */
    public int positiveIntNumber() {
        return intNumber(0, Integer.MAX_VALUE);
    }

    /**
     * Generates an int number in [{@code min} ; {@code max}].
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.intNumber(-5, 5); // -> -4
     *         vp.intNumber(-5, 5); // -> 3
     * </pre>
     * </p>
     *
     * @param min the minimum value of the returned number.
     * @param max the maximum value of the returned number.
     * @return the generated number.
     * @see #positiveIntNumber()
     */
    public int intNumber(int min, int max) {
        return (int) longNumber(min, max);
    }

    /**
     * Generates a long number in [0 ; {@link Long#MAX_VALUE}].
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.positiveLongNumber(); // -> 2346841234567L
     * </pre>
     * </p>
     *
     * @return the generated number.
     * @see #longNumber(long, long)
     */
    public long positiveLongNumber() {
        return longNumber(0, Long.MAX_VALUE);
    }

    /**
     * Generates a long number in [{@code min} ; {@code max}].
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.longNumber(-15L, 15L); // -> -14L
     *         vp.longNumber(-5123456789L, 5123456789L); // -> 4123456987L
     * </pre>
     * </p>
     *
     * @param min the minimum value of the returned number.
     * @param max the maximum value of the returned number.
     * @return the generated number.
     * @see #positiveLongNumber()
     */
    public long longNumber(long min, long max) {
        return randomBigIntegerNumber(BigInteger.valueOf(min), BigInteger.valueOf(max)).longValue();
    }

    /**
     * Generates a {@link BigInteger} in [0 ; {@link Long#MAX_VALUE}].
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.positiveBigIntegerNumber(); // -> BigInteger[2346841234567L]
     * </pre>
     * </p>
     *
     * @return the generated number.
     * @see #bigIntegerNumber(BigInteger, BigInteger)
     */
    public BigInteger positiveBigIntegerNumber() {
        return bigIntegerNumber(BigInteger.ZERO, BigInteger.valueOf(Long.MAX_VALUE));
    }

    /**
     * Generates a {@link BigInteger} in [{@code min} ; {@code max}].
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.bigIntegerNumber(BigInteger.valueOf(-5123456789L), BigInteger.valueOf(5123456789L)); // -> BigInteger[4123456987L]
     * </pre>
     * </p>
     *
     * @param min the minimum value of the returned number.
     * @param max the maximum value of the returned number.
     * @return the generated number.
     * @see #positiveBigIntegerNumber()
     */
    public BigInteger bigIntegerNumber(BigInteger min, BigInteger max) {
        return randomBigIntegerNumber(min, max);
    }

    /**
     * Generates a {@link BigDecimal} in [0 ; {@code Double.MAX_VALUE}].
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.positiveBigDecimalNumber(); // -> BigDecimal[23468412345.5]
     * </pre>
     * </p>
     *
     * @return the generated number
     * @see #bigDecimalNumber(Number, Number)
     */
    public BigDecimal positiveBigDecimalNumber() {
        return bigDecimalNumber(BigDecimal.ZERO, BigDecimal.valueOf(Double.MAX_VALUE));
    }

    /**
     * Generates a {@link BigDecimal} in [{@code min} ; {@code max}].
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.bigDecimalNumber(-5123456789L, 5123456789L); // -> BigDecimal[4123456987.5]
     * </pre>
     * </p>
     *
     * @param min the minimum value of the returned number.
     * @param max the maximum value of the returned number.
     * @return the generated number.
     * @see #positiveBigDecimalNumber()
     */
    public BigDecimal bigDecimalNumber(Number min, Number max) {
        return bigDecimalNumber(BigDecimal.valueOf(min.doubleValue()), BigDecimal.valueOf(max.doubleValue()));
    }

    /**
     * Generates a BigDecimal in [{@code min} ; {@code max}].
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.bigDecimalNumber(BigDecimal.valueOf(-5123456789f), BigDecimal.valueOf(5123456789f)); // -> BigDecimal[4123456987.5]
     * </pre>
     * </p>
     *
     * @param min the minimum value of the returned number.
     * @param max the maximum value of the returned number.
     * @return the generated number.
     * @see #positiveBigDecimalNumber()
     */
    public BigDecimal bigDecimalNumber(BigDecimal min, BigDecimal max) {
        return max.compareTo(min) > 0
                ? min.add(max.subtract(min).multiply(BigDecimal.valueOf(random.nextDouble())))
                : min;
    }

    private BigInteger randomBigIntegerNumber(BigInteger min, BigInteger max) {
        if (max.compareTo(min) <= 0) {
            return min;
        }
        BigInteger diff = max.subtract(min).add(BigInteger.ONE);
        BigInteger randomDiff = BigInteger.valueOf(random.nextLong()).mod(diff);
        return min.add(randomDiff);
    }

    /**
     * Generates a {@link BigDecimal} with {@code scale} ({@link BigDecimal#scale()}) in [{@code min} ; {@code max}],
     * if {@code min} and {@code max} do not have a higher scale than {@code scale}.
     * <p>
     * Otherwise, the least significant digit may be outside the specified interval.
     * </p>
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.bigDecimalNumberWithScale(1.001, 1.004, 2); // -> BigDecimal[1.00]
     *         vp.bigDecimalNumberWithScale(1.001, 5.004, 5); // -> BigDecimal[3.00384]
     * </pre>
     * </p>
     *
     * @param min   the minimum value of the returned number.
     * @param max   the maximum value of the returned number.
     * @param scale the scale to be set on the BigDecimal.
     * @return the generated number.
     */
    public BigDecimal bigDecimalNumberWithScale(Number min, Number max, int scale) {
        BigDecimal result = bigDecimalNumber(min, max);
        return result.setScale(scale, RoundingMode.HALF_EVEN);
    }

    /**
     * Generates a {@link BigDecimal} with {@code scale} ({@link BigDecimal#scale()}) in [{@code min} ; {@code max}],
     * if {@code min} and {@code max} do not have a higher scale than {@code scale}.
     * <p>
     * Otherwise, the least significant digit may be outside the specified interval.
     * </p>
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.bigDecimalNumberWithScale(BigDecimal.valueOf(1.001), BigDecimal.valueOf(1.004), 2); // -> BigDecimal[1.00]
     * </pre>
     * </p>
     *
     * @param min   the minimum value of the returned number.
     * @param max   the maximum value of the returned number.
     * @param scale the scale to be set on the BigDecimal.
     * @return the generated number.
     */
    public BigDecimal bigDecimalNumberWithScale(BigDecimal min, BigDecimal max, int scale) {
        BigDecimal result = bigDecimalNumber(min, max);
        return result.setScale(scale, RoundingMode.HALF_EVEN);
    }

    /**
     * Returns the reference {@link LocalDateTime} as passed in the {@link ValueProviderInitialization}.
     * <p><b>Note:</b>
     * When initializing the {@link ValueProvider} via {@link ValueProviderFactory#createRandomValueProvider()}, this yields the current {@link LocalDateTime}, as produced by {@link LocalDateTime#now()}.
     * </p>
     *
     * @return the reference {@link LocalDateTime}.
     */
    public LocalDateTime fixedLocalDateTime() {
        return referenceLocalDateTime;
    }

    /**
     * Returns the reference {@link LocalDate} as passed in the {@link ValueProviderInitialization}.
     * <p><b>Note:</b>
     * When initializing the {@link ValueProvider} via {@link ValueProviderFactory#createRandomValueProvider()}, this yields the current {@link LocalDate}, as produced by {@link LocalDate#now()}.
     * </p>
     *
     * @return the reference {@link LocalDate}.
     */
    public LocalDate fixedLocalDate() {
        return fixedLocalDateTime().toLocalDate();
    }

    /**
     * Draws a {@link LocalDate} in [1st of January of {@code begin} ; 31st of December of {@code end}].
     *
     * @param begin minimum year to draw from.
     * @param end   maximum year to draw from.
     * @return the drawn {@link LocalDate}.
     * @throws IllegalArgumentException if {@code end} &lt; {@code begin}.
     */
    public LocalDate localDateBetweenYears(int begin, int end) {
        checkArgument(begin <= end, "begin %s must be before end %s", begin, end);
        LocalDate lower = LocalDate.of(begin, Month.JANUARY, 1);
        LocalDate upper = LocalDate.of(end, Month.DECEMBER, 31);
        return lower.plusDays(longNumber(0, DAYS.between(lower, upper)));
    }

    /**
     * Generates a {@link LocalTime}.
     *
     * @return the generated {@link LocalTime}
     */
    public LocalTime localTime() {
        long secondsPerDay = Duration.ofDays(1).get(SECONDS);
        return LocalTime.ofSecondOfDay(longNumber(0, secondsPerDay));
    }

    /**
     * Draws one element from the elements of an Enum class.
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.oneOf(Hobbit.class); // -> Hobbit[PIPPIN]
     * </pre>
     * </p>
     *
     * @param enumClass the enum to draw from.
     * @return the drawn value.
     * @see #oneOfExcluding(Enum[])
     */
    public <T extends Enum<?>> T oneOf(Class<T> enumClass) {
        return oneOf(enumClass.getEnumConstants());
    }

    /**
     * Draws one element from the provided elements.
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.oneOf(Hobbit.SAM, Hobbit.MERRY); // -> Hobbit[MERRY]
     *         vp.oneOf("Bran", "Jon", "Arya"); // -> "Jon"
     * </pre>
     * </p>
     *
     * @param firstElement    the first element.
     * @param furtherElements additional elements.
     * @return the drawn element.
     */
    @SafeVarargs
    public final <T> T oneOf(T firstElement, T... furtherElements) {
        return oneOf(asList(firstElement, furtherElements));
    }

    /**
     * Draws one element from an array of elements.
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.oneOf(new String[]{"Bran", "Jon", "Arya"}); // -> "Arya"
     * </pre>
     * </p>
     *
     * @param elements the array of elements.
     * @return the drawn element.
     * @throws IllegalArgumentException if empty {@code elements} are provided.
     */
    public <T> T oneOf(T[] elements) {
        return oneOf(asList(elements));
    }

    /**
     * Draws one element from {@code elements}.
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.oneOf(List.of("Bran", "Jon", "Arya")); // -> "Bran"
     * </pre>
     * </p>
     *
     * @param elements an {@link Iterable} of elements.
     * @return the drawn element.
     * @throws IllegalArgumentException if empty {@code elements} are provided.
     * @see #oneOfExcluding(Iterable, Object[])
     */
    public <T> T oneOf(Iterable<T> elements) {
        if (Iterables.isEmpty(elements)) {
            throw new IllegalArgumentException("No elements provided for method oneOf(), at least one element is necessary.");
        }
        return Iterables.get(elements, intNumber(0, Iterables.size(elements) - 1));
    }

    /**
     * Draws some elements from the elements of an Enum class. This potentially yields no elements at all (= emtpy set), as well as all elements.
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.someOf(Hobbit.class); // -> Set[Hobbit[PIPPIN]]
     *         vp.someOf(Hobbit.class); // -> Set[]
     *         vp.someOf(Hobbit.class); // -> Set[Hobbit[PIPPIN], Hobbit[MERRY], Hobbit[FRODO], Hobbit[SAM]]
     * </pre>
     * </p>
     *
     * @param enumClass the enum to draw from.
     * @return the drawn elements (none / some / all).
     */
    public <T extends Enum<T>> Set<T> someOf(Class<T> enumClass) {
        Collection<T> set = someOf(EnumSet.allOf(enumClass));
        if (set.isEmpty()) {
            return EnumSet.noneOf(enumClass);
        }
        return EnumSet.copyOf(set);
    }

    /**
     * Draws {@code numberOfElements} elements from the elements of an Enum class.
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.someOf(Hobbit.class, 2); // -> Set[Hobbit[PIPPIN], Hobbit[MERRY]]
     * </pre>
     * </p>
     *
     * @param enumClass        the enum to draw from.
     * @param numberOfElements the number of elements to draw.
     * @return the drawn elements.
     * @throws IllegalArgumentException if {@code enumClass} has fewer than {@code numberOfElements} elements.
     */
    public <T extends Enum<T>> Set<T> someOf(Class<T> enumClass, int numberOfElements) {
        return EnumSet.copyOf(someOf(EnumSet.allOf(enumClass), numberOfElements));
    }

    /**
     * Draws some elements from a collection of elements. This potentially yields no elements at all (= emtpy collection), as well as all elements.
     * Takes duplicates into account. Thus, duplicates in the input might yield duplicates in the output.
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.someOf(Hobbit.SAM, Hobbit.MERRY); // -> Collection[Hobbit[MERRY]]
     *         vp.someOf(1, 2, 3); // -> Collection[]
     *         vp.someOf("Bran", "Jon", "Arya"); // -> Collection["Jon", "Arya", "Bran"]
     * </pre>
     * </p>
     *
     * @param elements the elements to draw from.
     * @return the drawn elements (none / some / all).
     */
    @SafeVarargs final public <T> Collection<T> someOf(T... elements) {
        return someOf(asList(elements));
    }

    /**
     * Draws some elements from a collection of elements. This potentially yields no elements at all (= emtpy collection), as well as all elements.
     * Takes duplicates into account. Thus, duplicates in the input might yield duplicates in the output.
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.someOf(List.of(Hobbit.SAM, Hobbit.MERRY)); // -> Collection[Hobbit[MERRY]]
     *         vp.someOf(List.of(1, 2, 3)); // -> Collection[]
     *         vp.someOf(List.of("Bran", "Jon", "Arya")); // -> Collection["Jon", "Arya", "Bran"]
     * </pre>
     * </p>
     *
     * @param elements the elements to draw from.
     * @return the drawn elements (none / some / all).
     */
    public <T> Collection<T> someOf(Iterable<T> elements) {
        return someOf(elements, intNumber(1, Iterables.size(elements)));
    }

    /**
     * Draws {@code numberOfElements} elements from a collection of elements.
     * Takes duplicates into account. Thus, duplicates in the input might yield duplicates in the output.
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.someOf(List.of("Bran", "Jon", "Arya"), 2); // -> Collection["Jon", "Bran"]
     * </pre>
     * </p>
     *
     * @param elements         the elements to draw from.
     * @param numberOfElements the number of elements to draw.
     * @return the drawn elements.
     * @throws IllegalArgumentException if {@code elements} has fewer than {@code numberOfElements} elements.
     */
    public <T> Collection<T> someOf(Iterable<T> elements, int numberOfElements) {
        checkArgument(Iterables.size(elements) >= numberOfElements,
                "cannot draw %s elements from %s, since it contains only %s elements", numberOfElements, elements, Iterables.size(elements));
        List<T> result = new ArrayList<>();
        List<T> elementsAsList = newArrayList(elements);
        for (int i = 0; i < numberOfElements; i++) {
            result.add(elementsAsList.remove(intNumber(0, elementsAsList.size() - 1)));
        }
        return result;
    }

    /**
     * Draws one element from the elements of an Enum class T, but excludes the {@code elementsToExclude}.
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.oneOfExcluding(Hobbit.SAM, Hobbit.PIPPIN); // -> Hobbit[FRODO]
     * </pre>
     * </p>
     *
     * @param elementsToExclude elements that should not be drawn.
     * @return the drawn value.
     * @throws IllegalArgumentException if no elements are left after the exclusion.
     * @see #oneOf(Class)
     */
    @SafeVarargs
    public final <T extends Enum<T>> T oneOfExcluding(T... elementsToExclude) {
        return oneOf(EnumSet.complementOf(EnumSet.copyOf(asList(elementsToExclude))));
    }

    /**
     * Draws one element from {@code elements}, but never one of {@code elementsToExclude}.
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.oneOfExcluding(Lists.newArrayList("Bran", "Jon", "Sansa"), "Sansa", "Robb"); // -> "Jon" or "Bran"; "Robb" is superfluous but still valid
     * </pre>
     * </p>
     *
     * @param elements          an {@link Iterable} of elements.
     * @param elementsToExclude elements that should not be drawn.
     * @return the drawn element.
     * @throws IllegalArgumentException if {@code elements} is empty or if no elements are left after the exclusion.
     * @see #oneOf(Iterable)
     */
    @SafeVarargs
    public final <T> T oneOfExcluding(Iterable<T> elements, T... elementsToExclude) {
        Set<T> allElements = newHashSet(elements);
        allElements.removeAll(newHashSet(elementsToExclude));
        return oneOf(allElements);
    }

    /**
     * Randomly draws true or false.
     *
     * @return true or false (at random).
     */
    public boolean booleanValue() {
        return random.nextBoolean();
    }

    /**
     * Generates an IPv4 or IPv6 address.
     *
     * @return the generated address.
     */
    public String ipAddress() {
        return booleanValue() ? ipV4Address() : ipV6Address();
    }

    /**
     * Generates an IPv4 address.
     *
     * @return the generated address.
     */
    public String ipV4Address() {
        DecimalFormat threeDigits = new DecimalFormat("000");
        List<String> parts = new ArrayList<>();
        for (int i = 0; i < 4; i++) {
            parts.add(threeDigits.format(intNumber(1, 255)));
        }
        return parts.stream()
                .map(String::toString)
                .collect(Collectors.joining("."));
    }

    /**
     * Generates an IPv6 address.
     *
     * @return the generated address.
     */
    public String ipV6Address() {
        List<String> blocks;
        if (booleanValue()) {
            blocks = createPureIPv6AddressBlocks();
        } else {
            blocks = createIPv6AddressBlocksEndingWithIPv4();
        }

        boolean truncateLeadingZeros = booleanValue();
        String address = String.join(":", truncateLeadingZeros ? truncateLeadingZerosFromBlocks(blocks) : blocks);
        if (truncateLeadingZeros && booleanValue()) {
            address = mergeZeroGroups(address);
        }

        return address;
    }

    private List<String> createPureIPv6AddressBlocks() {
        List<String> blocks = new ArrayList<>();
        for (int i = 0; i < 8; i++) {
            blocks.add(createIPv6Block());
        }
        return blocks;
    }

    private List<String> createIPv6AddressBlocksEndingWithIPv4() {
        List<String> blocks = new ArrayList<>();
        for (int i = 0; i < 6; i++) {
            blocks.add(createIPv6Block());
        }
        blocks.add(ipV4Address());
        return blocks;
    }

    private String createIPv6Block() {
        return format("%04x", intNumber(0, 0xFFFF));
    }

    private List<String> truncateLeadingZerosFromBlocks(List<String> blocks) {
        return blocks.stream().map(this::truncateLeadingZerosFromBlock).collect(Collectors.toList());
    }

    private String truncateLeadingZerosFromBlock(String block) {
        return block.replaceFirst("(^0+)(?!$)", "");
    }

    private String mergeZeroGroups(String address) {
        return address.replaceFirst("(:0)+(?!$)", ":");
    }

    /**
     * Generates a {@link URL}. Randomly uses http or https as its scheme.
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.url(); // -> "http://www.domaineFg.com"
     *         vp.url(); // -> "https://domaineFg.de"
     * </pre>
     * </p>
     *
     * @return the generated URL.
     */
    public URL url() {
        return url(fixedDecoratedString("domain"));
    }

    /**
     * Generates a {@link URL} using {@code domain}. Randomly uses http or https as its scheme.
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.url("foo"); // -> "http://foo.com"
     * </pre>
     * </p>
     *
     * @param domain the domain of the {@link URL}.
     * @return the generated URL.
     * @throws IllegalArgumentException if {@code domain} yields an invalid {@link URL}.
     */
    public URL url(String domain) {
        return booleanValue() ? httpUrl(domain) : httpsUrl(domain);
    }

    /**
     * Generates a {@link URL}. Uses http as its scheme.
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.httpUrl(); // -> "http://domainStu.com"
     * </pre>
     * </p>
     *
     * @return the generated URL.
     */
    public URL httpUrl() {
        return httpUrl(fixedDecoratedString("domain"));
    }

    /**
     * Generates a {@link URL}. Uses http as its scheme. Uses {@code domain} as its domain.
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.httpUrl("mydomain"); // -> "http://www.mydomain.com"
     * </pre>
     * </p>
     *
     * @param domain the domain of the {@link URL}.
     * @return the generated URL.
     * @throws IllegalArgumentException if {@code domain} yields an invalid {@link URL}.
     */
    public URL httpUrl(String domain) {
        return createUrl("http", domain);
    }

    /**
     * Generates a {@link URL}. Uses https as its scheme.
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.httpsUrl(); // -> "https://domainUVw.co.uk"
     * </pre>
     * </p>
     *
     * @return the generated URL.
     */
    public URL httpsUrl() {
        return httpsUrl(fixedDecoratedString("domain"));
    }

    /**
     * Generates a {@link URL}. Uses https as its scheme. Uses {@code domain} as its domain.
     * <p>
     * Example:
     * <pre>
     *         ValueProvider vp = ValueProviderFactory.createRandomValueProvider();
     *         vp.httpsUrl("somedomain"); // -> "https://somedomain.co.uk"
     * </pre>
     * </p>
     *
     * @return the generated URL.
     * @throws IllegalArgumentException if {@code domain} yields an invalid {@link URL}.
     */
    public URL httpsUrl(String domain) {
        return createUrl("https", domain);
    }

    private URL createUrl(String scheme, String domain) {
        String optionalWWWPrefix = "";
        if (!domain.startsWith("www")) {
            optionalWWWPrefix = booleanValue() ? "www." : "";
        }
        String countrySuffix = oneOf("de", "com", "net", "co.uk");
        try {
            return new URL(format("%s://%s%s.%s", scheme, optionalWWWPrefix, domain, countrySuffix));
        } catch (MalformedURLException e) {
            throw new IllegalArgumentException(format("Illegal domain %s", domain));
        }
    }

    String getPrefix() {
        return prefix;
    }

    String getSuffix() {
        return suffix;
    }

    RandomValues getRandom() {
        return random;
    }

    @Override
    public int hashCode() {
        return Objects.hash(random, prefix, suffix, referenceLocalDateTime);
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName() +
                "(random=" + random + ", " +
                "prefix=" + prefix + ", " +
                "suffix=" + suffix + ", " +
                "referenceLocalDateTime=" + referenceLocalDateTime + ")";
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        ValueProvider other = (ValueProvider) obj;
        return Objects.equals(random, other.random) &&
                Objects.equals(prefix, other.prefix) &&
                Objects.equals(suffix, other.suffix) &&
                Objects.equals(referenceLocalDateTime, other.referenceLocalDateTime);
    }

    public static class Builder {
        private final RandomValues random;
        private String prefix;
        private String suffix;
        private LocalDateTime referenceLocalDateTime;

        public Builder(ValueProvider from) {
            random = from.random;
            prefix = from.prefix;
            suffix = from.suffix;
            referenceLocalDateTime = from.referenceLocalDateTime;
        }

        public Builder(long seed) {
            this(new RandomValues(seed));
        }

        public Builder(RandomValues random) {
            this.random = random;
            prefix = "";
            suffix = createSuffix(random);
            referenceLocalDateTime = now().truncatedTo(SECONDS);
        }

        public Builder(ValueProviderInitialization initialization) {
            this.random = initialization.getRandom();
            prefix = "";
            suffix = initialization.getSuffix();
            referenceLocalDateTime = initialization.getReferenceLocalDateTime().truncatedTo(SECONDS);
        }

        static String createSuffix(RandomValues random) {
            return randomCharacters(MIXED_CASE_STRING, SUFFIX_LENGTH, random);
        }

        public Builder withConstantPrefix(String prefix) {
            this.prefix = prefix;
            return this;
        }

        public Builder withConstantSuffix(String suffix) {
            this.suffix = suffix;
            return this;
        }

        public Builder withReferenceLocalDateTime(LocalDateTime referenceLocalDateTime) {
            this.referenceLocalDateTime = referenceLocalDateTime;
            return this;
        }

        public ValueProvider build() {
            return new ValueProvider(random, prefix, suffix, referenceLocalDateTime);
        }
    }

    /**
     * Create a copy of the {@link ValueProvider} {@code source}, i.e. with the same seed and suffix, but a different {@code prefix}.
     * By convention, the suffix is used to mark test data that belong together, and is therefore shared when creating a hierarchy of test objects.
     * The prefix is used to differentiate multiple instances of a certain kind of data.
     * @param source {@link ValueProvider} to be copied
     * @param prefix to use (replaces the one that is potentially set for {@code source})
     * @return copy of {@link ValueProvider} with same seed an suffix, but changed {@code prefix}.
     */
    public static ValueProvider copyWithChangedPrefix(ValueProvider source, String prefix) {
        return new ValueProvider.Builder(source)
                .withConstantPrefix(prefix)
                .build();
    }
}
